<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>buffer - kotlinx-coroutines-core</title>
  <meta name="description" content="Library support for kotlin coroutines">
  <link rel="stylesheet" href="/kotlinx.coroutines/assets/main.css">
  <link rel="canonical" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="/kotlinx.coroutines/assets/js/api.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-47631155-3', 'auto');
    ga('send', 'pageview');
  </script>
</head>

  <body>
    <header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" href="/kotlinx.coroutines/">kotlinx.coroutines</a>
  </div>
</header>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="api-docs-breadcrumbs"><a href="../index.html">kotlinx-coroutines-core</a> / <a href="index.html">kotlinx.coroutines.flow</a> / <a href="./buffer.html">buffer</a></div>

<h1 id="buffer">buffer</h1>

<div class="signature"><code><span class="identifier">@ExperimentalCoroutinesApi</span> <span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span> <a href="-flow/index.html"><span class="identifier">Flow</span></a><span class="symbol">&lt;</span><a href="buffer.html#T"><span class="identifier">T</span></a><span class="symbol">&gt;</span><span class="symbol">.</span><span class="identifier">buffer</span><span class="symbol">(</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="parameterName" id="kotlinx.coroutines.flow$buffer(kotlinx.coroutines.flow.Flow((kotlinx.coroutines.flow.buffer.T)), kotlin.Int)/capacity">capacity</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a>&nbsp;<span class="symbol">=</span>&nbsp;BUFFERED<br /><span class="symbol">)</span><span class="symbol">: </span><a href="-flow/index.html"><span class="identifier">Flow</span></a><span class="symbol">&lt;</span><a href="buffer.html#T"><span class="identifier">T</span></a><span class="symbol">&gt;</span></code> <a href="https://github.com/kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-core/common/src/flow/operators/Context.kt#L108">(source)</a></div>

<p>Buffers flow emissions via channel of a specified capacity and runs collector in a separate coroutine.</p>

<p>Normally, <a href="-flow/index.html">flows</a> are <em>sequential</em>. It means that the code of all operators is executed in the
same coroutine. For example, consider the following code using <a href="on-each.html">onEach</a> and <a href="collect.html">collect</a> operators:</p>

<pre>flowOf("A", "B", "C")
    .onEach  { println("1$it") }
    .collect { println("2$it") }
</pre>

<p>It is going to be executed in the following order by the coroutine <code>Q</code> that calls this code:</p>

<pre>Q : --&gt;-- [1A] -- [2A] -- [1B] -- [2B] -- [1C] -- [2C] --&gt;--
</pre>

<p>So if the operator’s code takes considerable time to execute, then the total execution time is going to be
the sum of execution times for all operators.</p>

<p>The <code>buffer</code> operator creates a separate coroutine during execution for the flow it applies to.
Consider the following code:</p>

<pre>flowOf("A", "B", "C")
    .onEach  { println("1$it") }
    .buffer()  // &lt;--------------- buffer between onEach and collect
    .collect { println("2$it") }
</pre>

<p>It will use two coroutines for execution of the code. A coroutine <code>Q</code> that calls this code is
going to execute <code>collect</code>, and the code before <code>buffer</code> will be executed in a separate
new coroutine <code>P</code> concurrently with <code>Q</code>:</p>

<pre>P : --&gt;-- [1A] -- [1B] -- [1C] ----------&gt;--  // flowOf(...).onEach { ... }

                      |
                      | channel               // buffer()
                      V

Q : --&gt;---------- [2A] -- [2B] -- [2C] --&gt;--  // collect
</pre>

<p>When operator’s code takes time to execute this decreases the total execution time of the flow.
A <a href="../kotlinx.coroutines.channels/-channel/index.html">channel</a> is used between the coroutines to send elements emitted by the coroutine <code>P</code> to
the coroutine <code>Q</code>. If the code before <code>buffer</code> operator (in the coroutine <code>P</code>) is faster than the code after
<code>buffer</code> operator (in the coroutine <code>Q</code>), then this channel will become full at some point and will suspend
the producer coroutine <code>P</code> until the consumer coroutine <code>Q</code> catches up.
The <a href="buffer.html#kotlinx.coroutines.flow$buffer(kotlinx.coroutines.flow.Flow((kotlinx.coroutines.flow.buffer.T)), kotlin.Int)/capacity">capacity</a> parameter defines the size of this buffer.</p>

<h3 id="operator-fusion">Operator fusion</h3>

<p>Adjacent applications of <a href="channel-flow.html">channelFlow</a>, <a href="flow-on.html">flowOn</a>, <a href="./buffer.md">buffer</a>, <a href="produce-in.html">produceIn</a>, and <a href="broadcast-in.html">broadcastIn</a> are
always fused so that only one properly configured channel is used for execution.</p>

<p>Explicitly specified buffer capacity takes precedence over <code>buffer()</code> or <code>buffer(Channel.BUFFERED)</code> calls,
which effectively requests a buffer of any size. Multiple requests with a specified buffer
size produce a buffer with the sum of the requested buffer sizes.</p>

<h3 id="conceptual-implementation">Conceptual implementation</h3>

<p>The actual implementation of <code>buffer</code> is not trivial due to the fusing, but conceptually its
implementation is equivalent to the following code that can be written using <a href="../kotlinx.coroutines.channels/produce.html">produce</a>
coroutine builder to produce a channel and <a href="../kotlinx.coroutines.channels/consume-each.html">consumeEach</a> extension to consume it:</p>

<pre>fun &lt;T&gt; Flow&lt;T&gt;.buffer(capacity: Int = DEFAULT): Flow&lt;T&gt; = flow {
    coroutineScope { // limit the scope of concurrent producer coroutine
        val channel = produce(capacity = capacity) {
            collect { send(it) } // send all to channel
        }
        // emit all received values
        channel.consumeEach { emit(it) }
    }
}
</pre>

<h3 id="conflation">Conflation</h3>

<p>Usage of this function with <a href="buffer.html#kotlinx.coroutines.flow$buffer(kotlinx.coroutines.flow.Flow((kotlinx.coroutines.flow.buffer.T)), kotlin.Int)/capacity">capacity</a> of <a href="../kotlinx.coroutines.channels/-channel/-c-o-n-f-l-a-t-e-d.html">Channel.CONFLATED</a> is provided as a shortcut via
<a href="conflate.html">conflate</a> operator. See its documentation for details.</p>

<h3 id="parameters">Parameters</h3>

<p><code>capacity</code> - type/capacity of the buffer between coroutines. Allowed values are the same as in <code>Channel(...)</code>
factory function: <a href="../kotlinx.coroutines.channels/-channel/-b-u-f-f-e-r-e-d.html">BUFFERED</a> (by default), <a href="../kotlinx.coroutines.channels/-channel/-c-o-n-f-l-a-t-e-d.html">CONFLATED</a>,
<a href="../kotlinx.coroutines.channels/-channel/-r-e-n-d-e-z-v-o-u-s.html">RENDEZVOUS</a>, <a href="../kotlinx.coroutines.channels/-channel/-u-n-l-i-m-i-t-e-d.html">UNLIMITED</a> or a non-negative value indicating
an explicitly requested size.</p>

      </div>
    </main>
    <footer class="site-footer">
  <!-- empty -->
</footer>

  </body>
</html>

