<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>callbackFlow - kotlinx-coroutines-core</title>
  <meta name="description" content="Library support for kotlin coroutines">
  <link rel="stylesheet" href="/kotlinx.coroutines/assets/main.css">
  <link rel="canonical" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="/kotlinx.coroutines/assets/js/api.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-47631155-3', 'auto');
    ga('send', 'pageview');
  </script>
</head>

  <body>
    <header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" href="/kotlinx.coroutines/">kotlinx.coroutines</a>
  </div>
</header>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="api-docs-breadcrumbs"><a href="../index.html">kotlinx-coroutines-core</a> / <a href="index.html">kotlinx.coroutines.flow</a> / <a href="./callback-flow.html">callbackFlow</a></div>

<h1 id="callbackflow">callbackFlow</h1>

<div class="signature"><code><span class="identifier">@ExperimentalCoroutinesApi</span> <span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span> <span class="identifier">callbackFlow</span><span class="symbol">(</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="parameterName" id="kotlinx.coroutines.flow$callbackFlow(kotlin.SuspendFunction1((kotlinx.coroutines.channels.ProducerScope((kotlinx.coroutines.flow.callbackFlow.T)), kotlin.Unit)))/block">block</span><span class="symbol">:</span>&nbsp;<span class="keyword">suspend </span><a href="../kotlinx.coroutines.channels/-producer-scope/index.html"><span class="identifier">ProducerScope</span></a><span class="symbol">&lt;</span><a href="callback-flow.html#T"><span class="identifier">T</span></a><span class="symbol">&gt;</span><span class="symbol">.</span><span class="symbol">(</span><span class="symbol">)</span>&nbsp;<span class="symbol">-&gt;</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a><br /><span class="symbol">)</span><span class="symbol">: </span><a href="-flow/index.html"><span class="identifier">Flow</span></a><span class="symbol">&lt;</span><a href="callback-flow.html#T"><span class="identifier">T</span></a><span class="symbol">&gt;</span></code> <a href="https://github.com/kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-core/common/src/flow/Builders.kt#L331">(source)</a></div>

<p>Creates an instance of a <em>cold</em> <a href="-flow/index.html">Flow</a> with elements that are sent to a <a href="../kotlinx.coroutines.channels/-send-channel/index.html">SendChannel</a>
provided to the builderâ€™s <a href="callback-flow.html#kotlinx.coroutines.flow$callbackFlow(kotlin.SuspendFunction1((kotlinx.coroutines.channels.ProducerScope((kotlinx.coroutines.flow.callbackFlow.T)), kotlin.Unit)))/block">block</a> of code via <a href="../kotlinx.coroutines.channels/-producer-scope/index.html">ProducerScope</a>. It allows elements to be
produced by code that is running in a different context or concurrently.</p>

<p>The resulting flow is <em>cold</em>, which means that <a href="callback-flow.html#kotlinx.coroutines.flow$callbackFlow(kotlin.SuspendFunction1((kotlinx.coroutines.channels.ProducerScope((kotlinx.coroutines.flow.callbackFlow.T)), kotlin.Unit)))/block">block</a> is called every time a terminal operator
is applied to the resulting flow.</p>

<p>This builder ensures thread-safety and context preservation, thus the provided <a href="../kotlinx.coroutines.channels/-producer-scope/index.html">ProducerScope</a> can be used
from any context, e.g. from a callback-based API.
The resulting flow completes as soon as the code in the <a href="callback-flow.html#kotlinx.coroutines.flow$callbackFlow(kotlin.SuspendFunction1((kotlinx.coroutines.channels.ProducerScope((kotlinx.coroutines.flow.callbackFlow.T)), kotlin.Unit)))/block">block</a> completes.
<a href="../kotlinx.coroutines.channels/await-close.html">awaitClose</a> should be used to keep the flow running, otherwise the channel will be closed immediately
when block completes.
<a href="../kotlinx.coroutines.channels/await-close.html">awaitClose</a> argument is called either when a flow consumer cancels the flow collection
or when a callback-based API invokes <a href="../kotlinx.coroutines.channels/-send-channel/close.html">SendChannel.close</a> manually and is typically used
to cleanup the resources after the completion, e.g. unregister a callback.
Using <a href="../kotlinx.coroutines.channels/await-close.html">awaitClose</a> is mandatory in order to prevent memory leaks when the flow collection is cancelled,
otherwise the callback may keep running even when the flow collector is already completed.
To avoid such leaks, this method throws <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/IllegalStateException.html">IllegalStateException</a> if block returns, but the channel
is not closed yet.</p>

<p>A channel with the <a href="../kotlinx.coroutines.channels/-channel/-b-u-f-f-e-r-e-d.html">default</a> buffer size is used. Use the <a href="buffer.html">buffer</a> operator on the
resulting flow to specify a user-defined value and to control what happens when data is produced faster
than consumed, i.e. to control the back-pressure behavior.</p>

<p>Adjacent applications of <a href="./callback-flow.md">callbackFlow</a>, <a href="flow-on.html">flowOn</a>, <a href="buffer.html">buffer</a>, <a href="produce-in.html">produceIn</a>, and <a href="broadcast-in.html">broadcastIn</a> are
always fused so that only one properly configured channel is used for execution.</p>

<p>Example of usage that converts a multi-short callback API to a flow.
For single-shot callbacks use <a href="../kotlinx.coroutines/suspend-cancellable-coroutine.html">suspendCancellableCoroutine</a>.</p>

<pre>fun flowFrom(api: CallbackBasedApi): Flow&lt;T&gt; = callbackFlow {
    val callback = object : Callback { // Implementation of some callback interface
        override fun onNextValue(value: T) {
            // To avoid blocking you can configure channel capacity using
            // either buffer(Channel.CONFLATED) or buffer(Channel.UNLIMITED) to avoid overfill
            try {
                sendBlocking(value)
            } catch (e: Exception) {
                // Handle exception from the channel: failure in flow or premature closing
            }
        }
        override fun onApiError(cause: Throwable) {
            cancel(CancellationException("API Error", cause))
        }
        override fun onCompleted() = channel.close()
    }
    api.register(callback)
    /*
     * Suspends until either 'onCompleted'/'onApiError' from the callback is invoked
     * or flow collector is cancelled (e.g. by 'take(1)' or because a collector's coroutine was cancelled).
     * In both cases, callback will be properly unregistered.
     */
        awaitClose { api.unregister(callback) }
    }
</pre>

<p>The callback <code>register</code>/<code>unregister</code> methods provided by an external API must be thread-safe, because
 <code>awaitClose</code> block can be called at any time due to asynchronous nature of cancellation, even
 concurrently with the call of the callback.</p>


      </div>
    </main>
    <footer class="site-footer">
  <!-- empty -->
</footer>

  </body>
</html>

